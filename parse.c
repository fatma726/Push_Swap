/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fatmtahmdabrahym <fatmtahmdabrahym@stud    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/09 18:59:41 by fatmtahmdab       #+#    #+#             */
/*   Updated: 2025/08/10 00:54:11 by fatmtahmdab      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	get_size_max(char **str, int size)// array of strings, number of strings
{
	int	size_max;// كم رقم موجود// 
	int	i; // مجرد عداد نستخدمه عشان نمر ع المدخلات 
	int	j;// داخل السلسه نفسها 

	size_max = 0;
	i = 0;
	while (i < size)// طول ما i اقل من عدد السلاسل الي مستخدم دخلها 
	{
		j = 0;
		size_max += 1;// بحس اول عدد مباشره قبل ماادخل ف اللوب
		while (str[i][j])
		{
			if (str[i][j] == ' ')// طول ماهو مسافه
				size_max += 1; // بنزود عداد الارقام
			j++;//جوا السلسه
		}
		i++; // بروح ع السلسه الي بعدها
	}
	return (size_max); // كم رقم موجود عندنا دلوقتي
}

int	is_duplicates(t_stack *a)                       // بتشيك لو فيه أرقام مكرّرة في الstack A (ترجع 1 لو فيه، 0 لو مفيش)
{
	int	i;                                          // عدّاد للعنصر الأساسي اللي هنقارن منه
	int	j;                                          // عدّاد للعنصر اللي بعده اللي هنقارن بيه

	if (!a)                                         // لو الـpointer بتاع A أصلاً فاضي (NULL)
		return (0);                                  // مفيش بيانات نتأكد منها، نرجّع 0 وخلاص
	i = 0;                                          // نبدأ من أول عنصر
	while (i < a->size)                             // لفّي على كل عنصر موجود في المصفوفة
	{
		j = i + 1;                                   // خلّي المقارنة تبقى بس مع اللي بعد i عشان منكرّرش نفس المقارنات
		while (j < a->size)                          // لفّي على باقي العناصر اللي بعد i
		{
			if (a->array[i] == a->array[j])          // لو لقينا عنصرين قيمتهم متساوية
				return (1);                           // يبقى فيه تكرار (duplicate) → رجّعي 1 فورًا
			j++;                                      // جرّبي العنصر اللي بعده
		}
		i++;                                          // خلّصتي مقارنات العنصر i → زوّدي i وروحي للي بعده
	}
	return (0);                                      // لو خلّصتي اللوبات ومفيش مساواة، يبقى مفيش تكرار → رجّعي 0
}

static void	parse_split(char **split, t_stack *a, t_stack *b)   // دالة داخلية (static) بتقرا سترينجات الأرقام من split وتحطها في الstack A، ومعانا B عشان ننضّف لو حصل خطأ
{                                                               // بداية جسم الدالة
	int	i;                                                     // متغير عدّاد هنلف بيه على split

	i = 0;                                                     // نبدأ العدّاد من صفر
	while (split[i])                                           // طول ما فيه عنصر (سترينج) في split عند i
	{                                                          // بداية اللوب
		if (!is_digits(split[i]))                              // لو السترينج مش كله أرقام (فيه حروف/علامات غلط)
		{                                                      // خش نفّذ إجراءات الخطأ
			free_split(split);                                  // فك مصفوفة السترينجات عشان ميبقاش فيه تسريب ميموري
			free(a->array);                                     // فك مصفوفة A
			free(b->array);                                     // فك مصفوفة B
			put_error("Some arguments aren't integers.");       // اطبع رسالة خطأ وانهِ البرنامج
		}                                                      // نهاية if الأولى
		if (!is_int(split[i]))                                  // لو الرقم خارج مدى int (أكبر/أصغر من المسموح)
		{                                                      // إجراءات الخطأ برده
			free_split(split);                                  // فك مصفوفة السترينجات
			free(b->array);                                     // فك B (الترتيب هنا مش فارق عشان هنخرج)
			free(a->array);                                     // فك A
			put_error("Some arguments are bigger than an integer."); // اطبع رسالة مناسبة وانهِ البرنامج
		}                                                      // نهاية if التانية
		a->array[a->size] = ft_atoi(split[i]);                 // حوّل السترينج لرقم بـ ft_atoi وحطّه في آخر مكان فاضي في A
		a->size++;                                             // كبّري حجم A لأننا ضفنا عنصر جديد
		i++;                                                   // روّحي على العنصر اللي بعده في split
	}                                                          // نهاية اللوب
}                                                              // نهاية الدالة

void	parse(char **strings, t_stack *a, t_stack *b)// كل الارقام الي مستخدم دخلنا
{
	char	**tmp; // نقسم المدخلات ل مجموعه سلاسل اصغر كل سلسه فيها رقم لوحده
	int		i;//العداد

	i = 0;
	while (strings[i])
	{
		tmp = ft_split(strings[i], ' ');// كل الارقام ك عناصر منفصله
		if (!tmp || !tmp[0])
			free(tmp);
		parse_split(tmp, a, b);
		free_split(tmp);
		i++;
	}
	if (is_duplicates(a))
	{
		free_stacks(a, b);
		put_error("There are duplicates.");
	}
}
