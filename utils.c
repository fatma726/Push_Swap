/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fatmtahmdabrahym <fatmtahmdabrahym@stud    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/09 20:46:43 by fatmtahmdab       #+#    #+#             */
/*   Updated: 2025/08/10 00:56:51 by fatmtahmdab      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"                                     // الهيدر الرئيسي بتاع المشروع

void	free_split(char **split)                            // بتفكّ (free) مصفوفة سترينجات راجعة من split
{
	int	i;                                                 // عدّاد هنمشي بيه على العناصر

	if (!split)                                            // لو البوينتر نفسه NULL
		return;                                            // مفيش حاجة تتفك

	i = 0;                                                 // ابدأ من أول عنصر
	while (split[i])                                       // طول ما فيه سترينج عند i (لحد ما نوصل NULL اللي في الآخر)
	{
		free(split[i]);                                    // فكّ السترينج نفسه
		i++;                                               // روح للي بعده
	}
	free(split);                                           // وفي الآخر فكّ مصفوفة البوينترات نفسها
}

int	is_sorted(t_stack *a, t_stack *b)          // بتشيّك هل A مرتّبة تصاعدي وB فاضي (استخدمنا const لأننا مش هنعدّل)
{
	int	i;                                                 // عدّاد للمشي على عناصر A

	if (!a || !b || !a->array || !b->array)                // حماية من NULL: لو أي بوينتر/أراي فاضي
		return (0);                                        // اعتبرها مش مرتّبة (حالة غير صالحة)

	if (b->size > 0)                                       // لو فيه عناصر في B
		return (0);                                        // يبقى لسه مش الحالة النهائية

	if (a->size <= 1)                                      // لو A فاضي أو عنصر واحد
		return (1);                                        // يعتبر مرتّب تلقائيًا

	i = 0;                                                 // هنقارن كل عنصر باللي بعده
	while (i + 1 < a->size)                                // لحد قبل الأخير
	{
		if (a->array[i] > a->array[i + 1])                 // لو لقينا عنصر أكبر من اللي بعده
			return (0);                                    // يبقى مش تصاعدي → مش مرتّب
		i++;                                               // كمّلي
	}
	return (1);                                            // مفيش خروقات للترتيب وB فاضي → تمام
}

int	index_of(int *list, int size, int value)         // بترجّع أول إندكس لظهور value أو -1 لو مش موجود (list قراءة بس)
{
	int	i;                                                 // عدّاد للبحث الخطي

	if (!list || size <= 0)                                 // حماية: لو الليست NULL أو الحجم مش سليم
		return (-1);                                       // رجّع -1 كفشل/مش لاقي

	i = 0;                                                 // ابدأ من الأول
	while (i < size)                                       // لحد ما تخلص
	{
		if (list[i] == value)                              // لو لقينا القيمة
			return (i);                                    // رجّع مكانها
		i++;                                               // كمّل على الباقي
	}
	return (-1);                                           // خلّصنا ومفيش تطابق → -1
}
